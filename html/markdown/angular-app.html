<!-- Site built using grunt includes! -->
 <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Front End Development Note</title>
	<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" />
    <link type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" rel="stylesheet" />
	<link rel="stylesheet" href="http://gregfranko.com/jquery.tocify.js/css/jquery.ui.all.css" />
    <link rel="stylesheet" href="http://gregfranko.com/jquery.tocify.js/css/jquery.tocify.css" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r224/prettify.css" />
    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="http://mylko72.github.io/FEDNote/stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="http://mylko72.github.io/FEDNote/stylesheets/markdown.css">
    <link rel="stylesheet" href="http://mylko72.github.io/FEDNote/stylesheets/github.css">
    <link rel="stylesheet" href="/stylesheets/common.css">
    <link rel="stylesheet" href="/stylesheets/markdown-toc.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
	
	  <!-- header //-->
	  	      <header>
	  	        <h1>FED Note</h1>
	  	        <p>Front End Development</p>

	  	        <p class="view"><a href="https://github.com/mylko72/FEDNote">View the Project on GitHub <small>mylko72/FEDNote</small></a></p>
	  			<div id="toc"></div>

	  	        <!--<ul>
	  	          <li><a href="https://github.com/mylko72/FEDNote/zipball/master">Download <strong>ZIP File</strong></a></li>
	  	          <li><a href="https://github.com/mylko72/FEDNote/tarball/master">Download <strong>TAR Ball</strong></a></li>
	  	          <li><a href="https://github.com/mylko72/FEDNote">View On <strong>GitHub</strong></a></li>
	  			</ul>-->
	  	      </header>

	  <!--// header -->

      <section class="markdown-body">
		  <div id="preview">
		  <!-- start -->
		  <h1 id="angularjs-br-">AngularJS로 하는<br />웹 애플리케이션 개발</h1>
<h2 id="-">백엔드 서버와 통신</h2>
<h2 id="-">데이터 포맷과 출력</h2>
<h3 id="-">디렉티브에 대한 참조</h3>
<p>HTML 템플릿에서 디렉티브 참조 이름에는 접두사로 x나 data를 사용할 수 있다. 
data 접두사를 사용하면 HTML 문서가 HTML5를 준수하게 만드는 데 매우 편리하고, HTML5 유효성 테스트를 통과할 수 있게 해준다.</p>
<h3 id="-">표현식 평가 결과 출력</h3>
<h4 id="-">인터폴레이션 디렉티브</h4>
<p>이중괄호로 구성되는 표현식을 처리한다.</p>
<pre><code><span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="variable">{{expression}}</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></code></pre>
<p>AngularJS 표현식에 사용하는 구분자를 변경할 수 있다. 서버 측 다른 언어 템플릿과 AngularJS를 같이 사용해야 할 때 유용하다.</p>
<p><code>$interpolateProvider</code>의 설정 함수를 사용하면 된다.</p>
<pre><code class="lang-javascript">
myModule.config(<span class="keyword">function</span>($interpolateProvider){
    $interpolateProvider.startSymbol(<span class="string">'[['</span>);
    $interpolateProvider.endSymbol(<span class="string">']]'</span>);
});</code></pre>
<p>변경하고 나면 다음처럼 작성할 수 있다.</p>
<pre><code><span class="string">[[expression]]</span></code></pre>
<h4 id="ngbind-">ngBind로 모델 값 렌더링</h4>
<p>인터폴레이션 디렉티브는 <code>ng-bind</code>라는 디렉티브와 동일하다.</p>
<pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng-bind</span>=<span class="value">"expression"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></code></pre>
<p>보통 AngularJS가 첫 페이지를 로딩할 때 표현식이 처리되기 전에는 해당 표현식을 숨기고자 할 때 <code>ng-bind</code> 디렉티브를 사용한다.
이를 통해 UI가 깜빡거리는 현상을 막을 수 있어 사용자에게 더 좋은 경험을 제공한다.</p>
<h4 id="angularjs-html">AngularJS 표현식 안의 HTML</h4>
<p>기본적으로 AngularJS는 인터폴레이션 디렉티브가 평가하는 표현식 내부에 포함된 HTML 마크업은 처리하지 않는다.</p>
<pre><code class="lang-javascript">$scope.msg = <span class="string">'Hello, &lt;b&gt;World&lt;/b&gt;!'</span>;</code></pre>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="variable">{{msg}}</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></code></pre>
<p>이 마크업은 <code>&lt;b&gt;</code> 태그가 처리되지 않기 때문에 일반 문자열로 보여준다.</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello, &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></code></pre>
<p>이렇게 처리하는 이유는 HTML 주입 공격을 방지하기 위해서다.</p>
<p>모델에 담긴 HTML 마크업을 평가해서 렌더링할 특별한 이유가 있다면 HTML 태그 방지 기능을 꺼주는 <code>ng-bind-html-unsafe</code> 디렉티브를 사용하면 된다.</p>
<pre><code><span class="tag">&lt;<span class="title">p</span> <span class="attribute">ng-bind-html-unsafe</span>=<span class="value">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></code></pre>
<p>HTML 태그를 방지하는 또 하나의 디렉티브인 <code>ng-bind-html</code>도 있다.</p>
<pre><code><span class="tag">&lt;<span class="title">p</span> <span class="attribute">ng-bind-html</span>=<span class="value">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></code></pre>
<p>HTML 태그를 방지하는 면에 있어 <strong><em><code>ng-bind-html</code> 디렉티브는</em></strong> 모든 HTML 태그를 허용하는 <code>ng-bind-html-unsafe</code> 디렉티브와 HTML 태그를 전혀 허용하지 않는 인터폴레이션 디렉티브의 절충안이다. 특히 <strong><em>사용자가 입력한 HTML 태그만을 허용하고 싶은 경우에 쓰기 좋다.</em></strong></p>
<p><code>ng-bind-html</code> 디렉티브는 <code>angular-sanitize.js</code> 파일을 포함해야지만 사용할 수 있다. 그리고 <code>ngSanitize</code> 모듈에 대한 의존성을 선언해야 한다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'expressEscaping'</span>, [<span class="string">'ngSanitize'</span>])
    .controller(<span class="string">'ExpressionEscapingCtrl'</span>, <span class="keyword">function</span>($scope){
        $scope.msg = <span class="string">'Hello, &lt;b&gt;World&lt;/b&gt;!'</span>;    
    });</code></pre>
<h3 id="-">조건부 출력</h3>
<p>AngularJS는 4가지의 디렉티브를 제공한다.(ng-show/ng-hide, ng-switch-*, ng-if, ng-include).</p>
<p><code>ng-show/ng-hide</code>와 <code>ng-switch</code>의 가장 큰 차이점은 DOM 요소가 처리되는 방식이다. <code>ng-switch</code> 디렉티브는 DOM 트리에서 DOM 요소를 실제로 추가/삭제하는 반면
<code>ng-show/ng-hide</code> 디렉티브는 요소를 숨기기 위해 단순히 style=&quot;display:none;&quot;만 적용한다. 그리고 <code>ng-switch</code> 디렉티브는 새로운 스코프를 생성한다.</p>
<h4 id="-ng-include-">조건별로 특정 블럭 추가(ng-include)</h4>
<p><code>ng-include</code> 디렉티브는 AngularJS 기반의 마크업을 동적으로 특정 조건에 따라 보여줄 수 있다. 그래서 이 디렉티브를 사용하면 표현식 결과에 따라
화면을 다르게 보여줄 수 있다. 즉, 동적인 페이지를 쉽게 만들 수 있다.</p>
<p>다음은 관리자 권한을 가진 사용자에게만 다른 화면을 보여주는 코드이다.</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-include</span>=<span class="value">"user.admin &amp;&amp; 'edit.admin.html' || 'edit.user.html'"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<blockquote>
<p>관련내용</p>
<ul>
<li><a href="http://mylko72.maru.net/jquerylab/angularJS/angularjs.html?hn=1&amp;sn=7#h3_6">조건적인 데이터 표현을 위한 템플릿</a></li>
</ul>
</blockquote>
<h3 id="ngrepeat-">ngRepeat 디렉티브로 컬렉션 렌더링</h3>
<p><code>ng-repeat</code> 디렉티브는 컬렉션의 항목을 하나씩 순회하면서 항목마다 새로운 DOM 요소를 생성해준다. 단순히 컬렉션을 렌더링하는 일만 하는게 아니라 끊임없이
데이터를 지켜보다가 데이터가 변경되면 템플릿을 다시 그려주는 일도 해준다.</p>
<h4 id="-">특별한 변수</h4>
<p>AngularJS 반복자는 요소마다 생성된 스코프에 특별한 변수를 선언한다.</p>
<ul>
<li>$index 컬렉션에서 요소의 인덱스를 가리킨다(0부터 시작).</li>
<li>$first, $middle, $last  이 변수들은 요소의 위치에 따라 불리언 값을 가진다.</li>
</ul>
<p>다음은 <code>$last</code> 변수를 사용해 breadscrumb 요소에 대한 링크를 적절히 보여준다. 마지막 경로는 링크를 붙이지 않아도 되지만,
다른 경로들은 <code>&lt;a&gt;</code> 요소를 붙인다.</p>
<pre><code class="lang-javascript">&lt;li ng-repeat=<span class="string">"breadscrumb in breadscrumb.getAll()"</span>&gt;
    <span class="xml"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"divider"</span>&gt;</span>/<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ng-switch</span> <span class="attribute">on</span>=<span class="value">"$last"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng-switch-when</span>=<span class="value">"true"</span>&gt;</span>{{breadscrumb.name}}<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ng-switch-default</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"{{breadscrumb.path}}"</span>&gt;</span>{{breadscrumb.name}}<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">ng-switch</span>&gt;</span>
<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span></code></pre>
<h4 id="ngrepeat-ngclass-">ngRepeat패턴을 활용한 ngClass디렉티브</h4>
<p>리스트에 줄무늬 색을 입히는 건 가독성을 높이는 좋은 방법이다. 이를 위해 <code>ngClassEven</code>과 <code>ngClassOdd</code>라는 디렉티브를 제공한다.</p>
<pre><code><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"user in users"</span>
    <span class="attribute">ng-class-even</span>=<span class="value">"'light-gray'"</span> <span class="attribute">ng-class-odd</span>=<span class="value">"'dark-gray'"</span>&gt;</span>
    ...
<span class="tag">&lt;/<span class="title">tr</span>&gt;</span></code></pre>
<p><code>ngClass</code>는 매우 강력하며 <code>ngClass</code>룰 이용해 다시 작성할 수 있다.</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"user in users"</span>
    <span class="attribute">ng-class</span>=<span class="value">"{'dark-gray' : !</span><span class="variable">$index</span><span class="xml">%</span><span class="number">2</span><span class="xml">, 'light-gray' : </span><span class="variable">$index</span><span class="xml">%</span><span class="number">2</span><span class="xml">}"&gt;
    ...
<span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span></code></pre>
<p><code>ngClass</code> 디렉티브는 객체를 인자로 받는다. 이 객체는 클래스 이름을 키로 사용하고, 조건을 나타내는 표현식을 값으로 사용한다.
그리고 이 표현식의 평가 결과에 따라 키로 선언한 클래스를 요소에 추가하거나 삭제한다.</p>
<h4 id="ngrepeat-dom-">ngRepeat과 여러 DOM 요소</h4>
<p>ng-repeat은 형제 요소들을 관리하지 않는다. 이 말은 마치 ng-repeat 디렉티브를 사용하려면 컨테이너 요소가 필요하고, 특정 HTML 구조를 생성해야 하는 것처럼 보인다.
하지만 ng-repeat 디렉티브를 넣을 만한 HTML 요소가 없는 경우도 많다.
다음과 같은 이름과 세부내용으로 구성된 HTML을 사용해야 한다고 생각해 보자.</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="comment">&lt;!-- 반복자를 여기에 추가하고 싶다. --&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span><span class="variable">{{item.name}}</span><span class="tag">&lt;/<span class="title">strong</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="variable">{{item.description}}</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="comment">&lt;!-- 여기까지만 반복 --&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></code></pre>
<p>AngularJS 새 버전(1.2.x)부터는 ngRepeat 디렉티브의 기본 문법을 확장해 반복할 DOM 요소를 지정할 수 있다. 다시 작성하면 다음과 같다.</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat-start</span>=<span class="value">"item in items"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">strong</span>&gt;</span><span class="variable">{{item.name}}</span><span class="tag">&lt;/<span class="title">strong</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat-end</span>&gt;</span><span class="variable">{{item.description}}</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></code></pre>
<p><strong><em><code>ng-repeat-start</code>와 <code>ng-repeat-end</code> 속성을 사용함으로써 반복할 형제 DOM 요소 그룹을 지정할 수 있다.</em></strong></p>
<blockquote>
<p>관련내용</p>
<ul>
<li><a href="http://mylko72.maru.net/jquerylab/angularJS/angularjs.html?hn=1&amp;sn=7#h3_5">반복적인 데이터 표현을 위한 템플릿</a></li>
<li>예제) <a href="/angularjs/ngrepeat/index.html">ngRepeat 패턴을 이용한 list와 view</a></li>
</ul>
</blockquote>
<h3 id="dom-">DOM 이벤트 핸들러</h3>
<p>DOM 이벤트 핸들러에는 실제 DOM 이벤트를 가리키는 <code>$event</code> 라는 특별한 인자를 표현식에서 사용할 수 있다. <code>$event</code>를 통해 이벤트의 내부 프로퍼티에 접근할 수 있어 기본 동작을 변경하거나
이벤트가 전파되는 것을 막는 등의 추가 작업을 할 수 있다. 예를 들어 선택한 요소의 현재 위치를 어떻게 읽어오는지 보자.</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in items"</span> <span class="attribute">ng-click</span>=<span class="value">"logPosition(item, $event)"</span>&gt;</span>
        <span class="variable">{{item}}</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></code></pre>
<pre><code class="lang-javascript">    $scope.items = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>];

    $scope.logPosition = <span class="function"><span class="keyword">function</span> <span class="params">(item, $event)</span> {</span>
      console.log(item + <span class="string">' was clicked at: '</span> + $event.clientX + <span class="string">','</span> + $event.clientY);
    };</code></pre>
<blockquote>
<p>관련내용</p>
<ul>
<li><a href="http://mylko72.maru.net/jquerylab/angularJS/angularjs.html?hn=1&amp;sn=7#h3_9">이벤트 처리를 위한 템플릿</a></li>
</ul>
</blockquote>
<h3 id="-">필터로 모델 변형 다루기</h3>
<p>AngularJS 표현식에는 필터라는 특별한 포맷 함수를 지원한다.</p>
<pre><code>{{user.signedUp | <span class="built_in">date</span>:<span class="comment">'yyyy-MM-dd'}}</span></code></pre>
<p>이 코드는 사용자의 가입 날짜를 특정한 서식에 맞춰 표현하기 위해 date 필터를 사용한 예다. </p>
<p>필터는 뷰에서 파이프(|)를 사용해 호출하는 전역함수라고 보면 된다. 인자는 콜론(:)으로 구분한다. 예제 코드를 다음과 같이 formatDate 함수를 사용해 작성할 수도 있다.</p>
<pre><code><span class="variable">{{formatDate(user.signedUp, 'yyyy-MM-dd')}}</span></code></pre>
<p>필터는 매개 변수를 사용할 수 도 있고 여러개의 필터를 파이프라인으로 묶어 함께 사용(체인)할 수도 있다.</p>
<p>예를 들어 문자열의 길이를 80개로 제한하고 모든 글자를 소문자로 변경하는 코드는 다음과 같다.</p>
<pre><code><span class="tuple">{<span class="tuple">{my<span class="variable">LongString</span> | limit<span class="variable">To</span>:<span class="number">80</span> | lower<span class="keyword">case</span>}}</code></pre>
<h4 id="-">기본 제공 필터</h4>
<h5 id="-">서식 변경 필터</h5>
<p>currency | date | number | lowercase | uppercase | json</p>
<h5 id="-">배열 변경 필터</h5>
<p>limitTo | Filter | orderBy</p>
<h5 id="-filter-">&#39;filter&#39; 필터 적용</h5>
<p><code>filter</code> 필터는 배열의 부분 집합을 가져올 때 사용하는 일반적인 목적의 필터링 함수다.</p>
<pre><code>Search <span class="keyword">for</span> : &lt;input type=<span class="string">"text"</span> ng-model=<span class="string">"criteria"</span>&gt;
<span class="keyword">...</span>
<span class="keyword">...</span>
&lt;tr ng-<span class="keyword">repeat</span>=<span class="string">"backlogItem in backlog | filter:criteria"</span>&gt;
    <span class="keyword">...</span>
    <span class="keyword">...</span>
&lt;/tr&gt;</code></pre>
<p>입력창의 값을 필터의 인자로 연결하여 모든 항목에 대해 입력된 문자열을 포함하는 항목만 표시한다.</p>
<p>하지만 좀 더 정교하게 비교하고 싶다면 필터의 인자로 객체를 사용하면 된다.</p>
<p>이제 프로퍼티 중에 이름이 일치하고 아직 완료되지 않은 항목만 추리고 싶다고 해 보자.</p>
<pre><code><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in backlog | filter:{name: criteria, done: false}"</span>&gt;</span></code></pre>
<p>이 코드는 인자로 넘긴 객체의 모든 프로퍼티가 일치해야만 통과한다. 즉, AND 연산자로 묶는 것과 같다고 말할 수 있다.</p>
<p>객체의 모든 프로퍼티에 대해 문자열 비교를 하되 완료되지 않은 항목만 추리고 싶다면 다음과 같이 작성할 수 있다.</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in backlog | filter:{</span><span class="variable">$:</span><span class="xml"> criteria, done: false}"&gt;</span></code></pre>
<p>함수를 필터의 인자로 사용할 수 있다. 컬렉션의 항목마다 이 함수가 호출되며, 함수 호출 결과가 true인 항목만 결과 배열로 취함한다.</p>
<pre><code class="lang-javascript">$scope.doneAndBigEffort = <span class="keyword">function</span>(backlogItem){
    <span class="keyword">return</span> backlogItem.done &amp;&amp; backlogItem.estimation &gt; <span class="number">20</span>;
};</code></pre>
<pre><code><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in backlog | filter:doneAndBigEffort"</span>&gt;</span></code></pre>
<h5 id="-">걸러진 결과의 개수</h5>
<p>필터 적용 후의 결과에 대한 개수를 보여주고 싶다면 <em>걸러진 결과 값을 저장하는 변수를 생성</em>하면 된다.</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in filteredBacklog = (backlog | filter:{</span><span class="variable">$:</span><span class="xml"> criteria, done: false})"&gt;</span></code></pre>
<p>이제 걸러진 결과의 개수는 저장해둔 변수의 길이로 쉽게 알아낼 수 있다.</p>
<pre><code>Total : {{filteredBacklog.<span class="built_in">length</span>}}</code></pre>
<h5 id="orderby-">orderBy 필터로 정렬</h5>
<p><code>orderBy</code> 필터를 사용하면 테이블 데이터를 정렬할 수 있다. </p>
<pre><code><span class="tag">&lt;<span class="title">thead</span>&gt;</span>
    <span class="tag">&lt;<span class="title">th</span> <span class="attribute">ng-click</span>=<span class="value">"sort('name')"</span>&gt;</span>Name 
        <span class="tag">&lt;<span class="title">i</span> <span class="attribute">ng-class</span>=<span class="value">"{'icon-chevron-up':isSortUp('name'), 
        'icon-chevron-down':isSortDown('name')}"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">th</span>&gt;</span>
    <span class="tag">&lt;<span class="title">th</span> <span class="attribute">ng-click</span>=<span class="value">"sort('desc')"</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">th</span>&gt;</span>
    ...
<span class="tag">&lt;/<span class="title">thead</span>&gt;</span>
<span class="tag">&lt;<span class="title">tbody</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in filteredBacklogObj = (backlog | filter:criteria | orderBy:sortField:reverse)"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="variable">{{item.name}}</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="variable">{{item.desc}}</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        ...</code></pre>
<p>실제 정렬은 <code>orderBy</code> 필터로 수행되며 2개의 인자를 사용했다.</p>
<ul>
<li><strong>sortField</strong> 정렬 기준으로 사용할 프로퍼티의 이름</li>
<li><strong>정렬순서(reverse)</strong> 반대로 정렬하는지의 여부</li>
</ul>
<p>헤더를 클릭해서 호출되는 sort 함수는 정렬 순서를 바꾸는 것은 물론 정럴할 필드도 결정한다. 다음은 컨트롤러의 코드다.</p>
<pre><code class="lang-javascript">$scope.sortField = <span class="literal">undefined</span>;
$scope.reverse = <span class="literal">false</span>;

$scope.sort = <span class="function"><span class="keyword">function</span> <span class="params">(fieldName)</span> {</span>
  <span class="keyword">if</span> ($scope.sortField === fieldName) {
    $scope.reverse = !$scope.reverse;
  } <span class="keyword">else</span> {
    $scope.sortField = fieldName;
    $scope.reverse = <span class="literal">false</span>;
  }
};</code></pre>
<p>또한 정렬을 나타내는 아이콘을 추가할 수 있다. <code>ng-class</code> 디렉티브를 사용하여 함수가 반환하는 불런값이 true인 객체의 키를 클래스로 지정한다.</p>
<pre><code class="lang-javascript">$scope.isSortUp = <span class="function"><span class="keyword">function</span> <span class="params">(fieldName)</span> {</span>
  <span class="keyword">return</span> $scope.sortField === fieldName &amp;&amp; !$scope.reverse;
};
$scope.isSortDown = <span class="function"><span class="keyword">function</span> <span class="params">(fieldName)</span> {</span>
  <span class="keyword">return</span> $scope.sortField === fieldName &amp;&amp; $scope.reverse;
};</code></pre>
<h4 id="-">사용자 정의 필터 생성</h4>
<h5 id="-">페이지 번호 매기기 예제</h5>
<p>페이지 번호를 매기는 기능을 지원하기 위해서는 사용자 정의 필터를 작성해야 한다. 다음은 사용자 정의 필터 pagination 이다.</p>
<pre><code><span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"item in filteredBacklog = (backlog | pagination:pageNo:pageSize)"</span>&gt;</span></code></pre>
<p>pagination 필터는 표시할 페이지(인덱스)와 페이지의 크기(한 페이지에 표시할 목록의 수)를 나타내는 2개의 매개변수를 받는다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'arrayFilters'</span>, [])
    .filter(<span class="string">'pagination'</span>, <span class="keyword">function</span>(){
     <span class="keyword">return</span> <span class="keyword">function</span>(inputArray, selectedPage, pageSize) {
       <span class="keyword">var</span> start = selectedPage*pageSize;
       <span class="keyword">return</span> inputArray.slice(start, start + pageSize);
     };
    });</code></pre>
<p>필터도 한 모듈의 인스턴스로 등록한다. <code>filter</code> 메소드는 필터이름으로 호출되며, 팩토리 함수는 새로운 필터의 인스턴스를 생성한다. 그리고 등록된
팩토리 함수는 실제 필터 함수를 반환해준다.</p>
<p>pagination 필터링 함수의 첫번째 인자는 필터링할 입력 값이고, 뒤에 이어지는 매개변수는 필터 옵션을 의미한다.</p>
<p>다음은 컨트롤러의 코드이다. </p>
<pre><code class="lang-javascript"><span class="comment">//pagination</span>
$scope.pageSize = <span class="number">3</span>;
$scope.pages = [];
$scope.$watch(<span class="string">'filteredBacklog.length'</span>, <span class="keyword">function</span>(filteredSize){
  $scope.pages.length = <span class="number">0</span>;
  <span class="keyword">var</span> noOfPages = Math.ceil(filteredSize / $scope.pageSize);
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;noOfPages; i++) {
    $scope.pages.push(i);
  }
});

$scope.setActivePage = <span class="function"><span class="keyword">function</span> <span class="params">(pageNo)</span> {</span>
  <span class="keyword">if</span> (pageNo &gt;=<span class="number">0</span> &amp;&amp; pageNo &lt; $scope.pages.length) {
    $scope.pageNo = pageNo;
  }
};</code></pre>
<h4 id="-">자바스크립트 코드에서 필터 접근</h4>
<p>필터는 보통 마크업에서 파이프(|)를 사용하여 호출하지만 자바스크립트 코드에서도 필터 인스턴스에 접근할 수 있다. 이 방법으로 기존 필터를 합쳐
새로운 기능을 만들어낼 수 있다.</p>
<p>필터는 AngularJS의 의존성 주입 시스템으로 관리되는 어떤 객체에든 주입할 수 있다. 다음은 필터에 의존성을 정의하는 방법이다.</p>
<ul>
<li><em><code>$filter</code> 서비스</em></li>
<li><em><code>Filter</code>라는 접미사를 붙인 필터 이름</em></li>
</ul>
<p><em><code>$filter</code> 서비스는 이름을 기준으로 필터의 인스턴스를 찾는 함수이다.</em></p>
<p>다음은 limitTo와 비슷하게 문자열을 잘라내는 필터를 작성해보자. 새로 만들 필터는 문자열이 긴 경우 &#39;...&#39; 접미사를 추가하는 필터다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'trimFilter'</span>, [])
  .filter(<span class="string">'trim'</span>, <span class="keyword">function</span>($filter){

    <span class="keyword">var</span> limitToFilter =  $filter(<span class="string">'limitTo'</span>);

    <span class="keyword">return</span> <span class="keyword">function</span>(input, limit) {
      <span class="keyword">if</span> (input.length &gt; limit) {
        <span class="keyword">return</span> limitToFilter(input, limit-<span class="number">3</span>) + <span class="string">'...'</span>;
      }
      <span class="keyword">return</span> input;
    };
  });</code></pre>
<p><code>$filter(&#39;limitTo&#39;)</code> 함수를 사용하면 필터 이름을 기준으로 필터의 인스턴스를 받아올 수 있다.</p>
<p>다음은 좀 더 빠르게 동작하고 읽기 쉬운 구현 방법이다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'trimFilter'</span>, [])
  .filter(<span class="string">'trim'</span>, <span class="keyword">function</span>(limitToFilter){
    <span class="keyword">return</span> <span class="keyword">function</span>(input, limit) {
      <span class="keyword">if</span> (input.length &gt; limit) {
        <span class="keyword">return</span> limitToFilter(input, limit-<span class="number">3</span>) + <span class="string">'...'</span>;
      }
      <span class="keyword">return</span> input;
    };
  });</code></pre>
<blockquote>
<p>관련내용</p>
<ul>
<li><a href="http://mylko72.maru.net/jquerylab/angularJS/angularjs.html?hn=1&amp;sn=7#h2_8">필터를 사용하고 만들어 보자</a></li>
</ul>
</blockquote>
<h2 id="-">고급 폼 작성</h2>
<h2 id="-">내비게이션 구성</h2>
<p>AngularJS는 다음과 같은 것들을 지원한다.</p>
<ul>
<li>딥 링크 URL은 단일 페이지 웹 애플리케이션 내에서 특정 기능을 가리킨다. 그리고 이 URL은 북마크할 수 있고 없어질 수도 있다.</li>
<li>단일 웹 페이지 애플리케이션에서 서로 다른 화면 사이를 오갈 수 있는 브라우저의 뒤로가기, 앞으로 가기 버튼은 사요자 생각대로 동작한다.</li>
<li>브라우저에서 HTML5 API를 지원할 수 있게 URL은 간결하고 기억하기 쉬운 형태다.</li>
</ul>
<h3 id="-url">단일 페이지 웹 애플리케이션의 URL</h3>
<h4 id="html5-hashbang-url">HTML5 이전 시대의 hashbang URL</h4>
<p>현재 표시되는 페이지를 다시 로딩하지 않고 브라우저 주소 창의 URL에 # 문자를 사용하는 방법이 있는데 URL에 추가한 이 부분을 URL 조각(fragment)이라고 부른다. 이 URL 조각을 변경하면 브라우저의 히스토리 스택에 새로운 요소를 추가할 수 있고 뒤로 가기와 앞으로 가기도 동작하게 만들 수 있다.</p>
<p>단일 페이지 웹 애플리케이션의 # 문자를 사용해 전체 URL을 표현하면 다음과 같다.</p>
<ul>
<li><a href="http://myhost.com/#/admin/users/list">http://myhost.com/#/admin/users/list</a><br>기존 사용자의 목록을 보여주는 URL</li>
<li><a href="http://myhost.com/#/admin/users/new">http://myhost.com/#/admin/users/new</a><br>새로운 사용자를 추가하는 폼을 보여주는 URL</li>
<li><a href="http://myhost.com/#/admin/users/[userId">http://myhost.com/#/admin/users/[userId</a>]<br>ID가 [userId]인 기존 사용자 정보를 수정하는 폼을 보여주는 URL</li>
</ul>
<p>보통 단일 페이지 웹 애플리케이션의 내부만을 가리키는 URL은 <strong>hashbang URL</strong>을 사용해 표현한다. <strong>hashbang URL</strong> 스키마를 사용하면 브라우저 주소 창의 URL을 변경해도 페이지를 다시 로딩하지 않는다. 브라우저는 서로 다른 URL(앞부분은 같지만 # 문자부터의 URL 조각은 다른)을 받아 히스토리를 관리하고 뒤로가기/앞으로 가기 버튼을 처리한다. 게다가 URL 조각의 일부분을 변경해도 서버와 통신하는데 아무런 문제가 없다.</p>
<h4 id="html5-history-api">HTML5와 history API</h4>
<p>history API를 사용하면 서버를 실제로 갔다 오지 않아도 외부 리소스를 사용할 수 있다. 새로운 <code>history.pushState</code> 메소드를 사용하면 브라우저 히스토리 스택의 최상위에 원하는 URL을 집어넣을 수 있다. 또한 history APi에는 히스토리 스택의 변경 여부를 지켜보는 내부 메커니즘이 있다. 그래서 <code>window.onpopstate</code> 이벤트를 지켜보다가 이벤트가 발생하면 애플리케이션의 상태를 변경할 수 있다.</p>
<p>HTML5 history API를 사용하면 단일 페이지 웹 애플리케이션에서 URL을 잘 사용할 수 있으며(#트릭을 쓰지 않고도), URL을 북마크할 수 있고 뒤로 가기/앞으로 가기 버튼도 기대한 대로 동작하는 등 좋은 사용자 경험을 제공할 수 있다. 따라서 이전 예제의 URL은 다음과 같이 간단히 표현할 수 있다.</p>
<ul>
<li><a href="http://myhost.com/admin/users/list">http://myhost.com/admin/users/list</a>  </li>
<li><a href="http://myhost.com/admin/users/new">http://myhost.com/admin/users/new</a>  </li>
<li><a href="http://myhost.com/admin/users/[userId">http://myhost.com/admin/users/[userId</a>]  </li>
</ul>
<h3 id="-location-">$location 서비스 사용</h3>
<p>AngularJS는 URL을 한 단계 추상화한 <code>$location</code> 서비스라는 것을 제공한다. </p>
<h4 id="-location-api-url-">$location 서비스 API와 URL 이해</h4>
<p>사용자의 목록을 가리키는 URL이 있다고 해보자. 패스, 쿼리 문자열, 조각 등 가능한 컴포넌트를 URL에 모두 추가한다.</p>
<p>/admin/users/list?active=true#bottom</p>
<p>이 URL을 해석하면 관리자 페이지의 활성하된 모든 사용자 목록을 맨 아래로 스크롤한다.</p>
<p>위 URL을 HTML5로 표현하면 다음과 같다.</p>
<p><a href="http://myhost.com/myapp/admin/users/list?active=true#bottom">http://myhost.com/myapp/admin/users/list?active=true#bottom</a></p>
<p>hashbang 모드의 URL은 좀 더 길고 약간 더 보기 좋지 않다.</p>
<p><a href="http://myhost.com/myapp#/admin/users/list?active=true#bottom">http://myhost.com/myapp#/admin/users/list?active=true#bottom</a></p>
<p>사용하는 모드랑 상관없이 <code>$location</code> 서비스는 일관적인 API를 제공함으로써 둘 사이의 차이점을 없애버린다. 다음 표는 사용 가능한 API 메소드를 보여준다.</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>반환하는 값</th>
</tr>
</thead>
<tbody>
<tr>
<td>$location.url()</td>
<td>/admin/users/list?active=true#bottom</td>
</tr>
<tr>
<td>$location.path()</td>
<td>/admin/users/list</td>
</tr>
<tr>
<td>$location.search()</td>
<td>{active:true}</td>
</tr>
<tr>
<td>$location.hash()</td>
<td>Bottom</td>
</tr>
</tbody>
</table>
<p>모든 메소드가 URL의 각 컴포넌트에 대해 get과 set 동작을 모두 쓸수 있다. 예를 들어 URL 조각을 읽으려면 <code>$location.hash()</code>를 사용하고, 값을 설정하려면 <code>$location.hash(&#39;top&#39;)</code> 형태로 사용하면 된다.</p>
<p><code>$location</code> 서비스는 프로토콜(protocol()), 호스트(host()), 포트(port()), 절대 URL(absUrl())과 같은 메소드도 제공하며 게터로만 동작한다.</p>
<h4 id="-anchorscroll">$anchorScroll</h4>
<p>hashbang URL에 단점이 하나 있다. 일반적인 경우 # 문자 뒤에 오는 URL은 로드된 문서 내부를 돌아다니는 데 사용한다. 다음 URL이 있다고 해보자.</p>
<p><a href="http://myhost.com/myapp#/admin/users/list?active=true#bottom">http://myhost.com/myapp#/admin/users/list?active=true#bottom</a></p>
<p>hashbang 모드에서 브라우저는 두번째 해시(#bottom)가 문서 내부를 스크롤하는데 사용돼야 한다는 사실을 알 방법이 없다. 이럴때 AngularJS의 <code>$anchorScroll</code> 서비스가 필요하다. </p>
<p><code>$anchorScroll</code> 서비스는 기본적으로 URL 조각을 지켜보고 있다가 해시를 발견하면 문서 내부의 특정 영역으로 점프한다. 이 동작은 HTML5 모드는 물론 hashbang 모드에서도 정확하게 동작한다.</p>
<p><code>$anchorScroll</code> 서비스의 스크롤하는 동작을 좀 더 세밀하게 제어하고 싶다면 자동으로 URL 조각을 모니터링하는 기능을 사용하지 않으면 된다. 모듈의 설정 블록에서 <code>$anchorScrollProvider</code> 서비스의 <code>disableAutoScrolling()</code> 메소드를 다음과 같이 호출하면 이 기능을 끌 수 있다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'myModule'</span>, [])
    .config(<span class="keyword">function</span>($anchorScrollProvider){
        $anchorScrollProvider.disableAutoScrolling();
    });</code></pre>
<p>이렇게 설정하면 스크롤이 발생하는 모든 상황을 제어할 수 있다. 즉, 원하는 시점에 서비스의 함수인 `$anchorScroll()을 호출해 스크롤 동작을 만들 수 있다.</p>
<h3 id="angularjs-">AngularJS 내장 경로 서비스 사용</h3>
<p>AngularJS 프레임워크는 단일 페이지 웹 애플리케이션에서 경로를 설정하기 위해 <code>$route</code>라는 서비스를 기본으로 제공한다.</p>
<h4 id="-">기본적인 경로 정의</h4>
<p><em>AngularJS에서 경로는 애플리케이션의 설정 단계에서 <code>$routeProvider</code> 서비스를 통해 정의할 수 있다.</em></p>
<pre><code class="lang-javascript">angular.module(<span class="string">'routing_basics'</span>, [])
  .config(<span class="keyword">function</span>($routeProvider) {
    $routeProvider
      .when(<span class="string">'/admin/users/list'</span>, {templateUrl: <span class="string">'tpls/users/list.html'</span>})
      .when(<span class="string">'/admin/users/new'</span>,  {templateUrl: <span class="string">'tpls/users/new.html'</span>})
      .when(<span class="string">'/admin/users/edit'</span>, {templateUrl: <span class="string">'tpls/users/edit.html'</span>})
      .otherwise({redirectTo: <span class="string">'/admin/users/list'</span>});
  })</code></pre>
<p><code>$routeProvider</code> 서비스는 새로운 경로를 정의하는 메소드(when)와 기본 경로를 정의하는 메소드(otherwise)를 체이닝할 수 있는 유연한 API를 제공한다.</p>
<h5 id="-">- 일치하는 경로의 내용 보여주기</h5>
<p>URL이 경로 중 하나와 일치하면 경로의 내용(templateUrl)을 <code>ng-view</code> 디렉티브로 보여줄 수 있다.</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container-fluid"</span> <span class="attribute">ng-view</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<h4 id="-">변경되는 경로 찾기</h4>
<p>다음과 같이 URL 쿼리 매개변수를 사용해 사용자 id를 구분할 수 있다.</p>
<p>/admin/users/edit?user={{user.id}}</p>
<p>하지만 사용자 id를 다음과 같이 URL의 일부분으로 집어넣는 방식이 훨씬 낫다.</p>
<p>/admin/users/edit/{{user.id}}</p>
<p>AngularJS는 콜론(:)으로 구분한 문자열을 사용해 아주 쉽게 이 기능을 지원한다. 사용자의 ID를 URL의 일부분으로 처리하려면 URL 스키마를 다음과 같이 정의하면 된다.</p>
<pre><code class="lang-javascript">.when(<span class="string">'/admin/users/:userid'</span>, {templateUrl:<span class="string">'tpls/users/edit.html'</span>})</code></pre>
<h5 id="-">- 기본 경로 설정</h5>
<p>기본 경로는 <code>otherwise</code> 메소드를 사용해 설정할 수 있다. 기본 경로를 설정하면 일치하지 않는 모든 경로가 기본 경로로 처리된다.</p>
<h5 id="-">- 경로의 매개변수 값 사용</h5>
<p>특정 URL이 경로와 일치할 때 <code>$routeParams</code> 서비스를 사용하면 이 매개변수의 값에 쉽게 접근할 수 있다. 사실 <code>$routeParams</code> 서비스는 경로의 매개변수 이름을 키로 하고 일치하는 URL의 해당 문자열을 값으로 하는 간단한 자바스크립트 객체(해시)다.</p>
<p><code>$routeParams</code>는 일반적인 서비스이므로 AngularJS 의존성 주입 시스템이 관리하는 어떤 객체에든 주입할 수 있다. 사용자 정보를 수정(/admin/users/:userid)하는데 사용하는 컨트롤러에서 다음과 같이 정의할 수 있다.</p>
<pre><code class="lang-javascript">.controller(<span class="string">'EditUserCtrl'</span>, <span class="keyword">function</span>($scope, $routeParams, Users){
    $scope.user = Users.get({id: $routeParams.userid});
})</code></pre>
<p>이 코드는 /admin/users/edit로 정의한 경로와 일치하는 URL인 /admin/users/edit?userid=1234에 대해 동일하게 동작한다.</p>
<h4 id="-">경로설정 단계에서의 컨트롤러 정의</h4>
<p>AngularJS 경로 시스템은 경로를 정의할 때 컨트롤러도 같이 정의할 수 있는 기능을 제공한다.</p>
<pre><code class="lang-javascript">.when(<span class="string">'/admin/users/:userid'</span>, {
    templateUrl: <span class="string">'tpls/users/edit.html'</span>,
    controller: <span class="string">'EditUserCtrl'</span>
})</code></pre>
<h4 id="-">경로 변경시 깜빡거림 현상 제거</h4>
<p>애플리케이션에서 다른 화면으로 이동할 때는 해당되는 데이터 뿐만 아니라 새로운 화면에 대한 마크업도 가져와서 보여줘야 한다. 이때 새로운 화면을 그리기 위해 사용할 수 있는 2가지 다른 전략이 있다.</p>
<ul>
<li>새로운 마크업을 가능한 한 빨리 보여주고(데이터가 아직 준비되지 않았더라도) 백엔드로부터 데이터가 도착하면 UI를 다시 그리는 방법</li>
<li>백엔드에서 모든 요청이 처리되고 데이터가 준비된 후 새로운 경로에 대한 마크업을 보여주는 방법</li>
</ul>
<p>첫번째 방법이 기본으로 사용되는 바법이다. 하지만 사용자는 의도치 않은 깜빡거림 현상을 접하게 된다. UI가 깜빡거리는 현상은 같은 템플릿이 짧은 시간에 데이터 없이 한 번 그려지고 데이터가 준비되면 또다시 그려지기 때문에 발생하는 현상이다. </p>
<p>AngularJS 경로 시스템은 두 번째 방법을 구현하기 위해 템플릿과 필요한 데이터가 준비될 때까지 경로 변경(UI를 다시 그리는)을 미루는 멋진 기능을 제공한다. <strong><em>경로를 정의하는 객체에서 <code>resolve</code> 프로퍼티를 사용하면 경로의 컨트롤러에 대한 비동기적인 의존성을 정의할 수 있다.</em></strong> AngularJS는 경로가 변경되기 전에(컨트롤러를 초기화하기 전에) 이 의존성을 모두 처리해 준다.</p>
<p><code>resolve</code> 프로퍼티를 사용하는 방법에 대한 예로 사용자 정보를 수정하는 경로를 다시 작성해 보자.</p>
<pre><code class="lang-javascript">.when(<span class="string">'/admin/users/:userid'</span>, {
    templateUrl: <span class="string">'tpls/users/edit.html'</span>,
    controller: <span class="string">'EditUserCtrl'</span>,
    resolve: {
        user : <span class="keyword">function</span>($route, Users){
          <span class="keyword">return</span> Users.getById($route.current.params.userid);
        }
    }
})</code></pre>
<p><code>resolve</code> 프로퍼티는 객체다. <em>경로의 컨트롤러에 주입할 새로운 변수를 키로 정의하고 해당 변수로 제공할 특정 함수를 값으로 정의한다.</em> 물론 이 함수에서도 역시 AngularJS의 DI 시스템을 사용해 의존성을 주입할 수 있다. 예제에서는 사용자 데이터를 받아오기 위해 <code>$route</code>와 Users 서비스를 주입했다.</p>
<p>이 <code>resolve</code> 함수는 간단한 자바스크립트 값, 객체, 프라미스 등을 반환할 수 있다. 프라미스가 반환되면 AngularJS는 프라미스가 해결될 때까지 경로 변경을 미룬다. 비슷하게 <code>resolve</code> 함수가 여러 개의 프라미스를 반환하면 AngularJS 경로 시스템은 모든 프라미스가 해결되기 전까지는 경로를 변경하지 않는다.</p>
<p>경로 관련 변수(resolve로 정의한)가 모두 해결되고 나면 경로의 컨트롤러는 다음과 같이 주입된다.</p>
<pre><code class="lang-javascript">.controller(<span class="string">'EditUserCtrl'</span>, <span class="keyword">function</span>($scope, user){
    $scope.user = user;
    ...
})</code></pre>
<p>이 방법은 경로를 정의할 때 지역 변수를 선언함으로써 해당 경로의 컨트롤러에 이를 주입할 수 있으므로 매우 강력한 패턴이다</p>
<pre><code class="lang-javascript">$routeProvider.when(<span class="string">'/admin/users/new'</span>, {
    templateUrl: <span class="string">'tpls/users/users-edit.tpl..html'</span>,
    controller: <span class="string">'UsersEditCtrl'</span>,
    resolve: {
        user : <span class="keyword">function</span>(Users){
          <span class="keyword">return</span> <span class="keyword">new</span> Users(); 
        }
    }
})
$routeProvider.when(<span class="string">'/admin/users/new'</span>, {
    templateUrl: <span class="string">'tpls/users/users-edit.tpl.html'</span>,
    controller: <span class="string">'UsersEditCtrl'</span>,
    resolve: {
        user : <span class="keyword">function</span>($route, Users){
          <span class="keyword">return</span> Users.getById($route.current.params.userid);
        }
    }
})</code></pre>
<p>경로 정의 단계에서 지역변수를 선언(resolve 프로퍼티 안에)한다는 것은 이 지역 변수들이 경로와 함께 정의한 컨트롤러에 주입될 수 있다는 의미다.</p>
<h4 id="-">경로 변경 방지</h4>
<p>특정 조건에 따라 경로가 변경되는 것을 막아야 할 때가 있다. 예를 들어 사용자를 가리키는 id가 없는 경우 존재하지 않는 항목에 대해서는 해당 경로로 이동할 수 없게 만드는 것도 한 가지 방법이다.</p>
<p>/users/edit/:userid</p>
<p>경로의 <code>resolve</code>의 키로 프라미스를 사용하고 이 프라미스가 거부되면 AngularJS는 경로 변경 작업을 취소하고 템플릿을 변경하지 않는다.</p>
<p>거부된 프라미스로 인해 경로 접근 과정이 실패하면 브라우저의 주소 창과 보이는 UI가 안 맞는 현상이 발생한다.</p>
<h3 id="-route-">$route 서비스의 한계</h3>
<h4 id="-">한 화면의 한 영역에 대한 경로</h4>
<p><code>ng-view</code> 디렉티브를 사용하면 UI에 단 하나의 &#39;영역&#39;에 대해서만 <code>$route</code> 서비스로 내용을 보여줄 수 있다. 하지만 실제로는 경로를 변경하고 나서 화면의 여러 영역에 적절한 html 템플릿을 보여주어야 할 때가 많다. AngularJS를 가지고 이런 형태의 내비게이션을 구현하는 방법은 <code>ng-include</code> 디렉티브를 여러 번 사용하는 것 뿐이다.</p>
<h5 id="-ng-include-ui-">- ng-include로 여러 UI 영역 다루기</h5>
<p>경로를 정의하는 객체는 일반적인 자바스크립트 객체이므로 원하는 프로퍼티를 마음대로 추가할 수 있다. 추가로 넣은 프로퍼티는 <code>$route</code> 동작에 아무런 영향을 미치지 않는다.</p>
<p>이 방식으로 경로 정의 단계에서 menuUrl과 contentUrl 프로퍼티를 새로 추가 해보자.</p>
<pre><code class="lang-javascript">$routeProvider.when(<span class="string">'/admin/users/new'</span>, {
    templateUrl: <span class="string">'admin/admin.tpl.html'</span>,
    contentUrl: <span class="string">'admin/users/users-edit.tpl.html'</span>,
    menuUrl: <span class="string">'admin/menu.tpl.html'</span>,
    controller: <span class="string">'UsersEditCtrl'</span>,
    ...
})</code></pre>
<p>그러고 나서 templateUrl을 통해 호출되는 템플릿 문서는 메뉴와 내용을 처리하는 다음과 같은 새로운 템플릿 문서를 가리키게 설정해야 한다.</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-include</span>=<span class="value">"</span><span class="variable">$route.current.menuUrl</span><span class="xml">"&gt;
        <span class="comment">&lt;!-- 메뉴 --&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-include</span>=<span class="value">"</span><span class="variable">$route.current.contentUrl</span><span class="xml">"&gt;
        <span class="comment">&lt;!-- 내용 --&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></code></pre>
<p>하지만 이 방법은 경로가 변경될때마다 menu DOM 요소를 매번 다시 그리는 단점이 있다.</p>
<h3 id="-">경로 패턴, 팁, 트릭</h3>
<h4 id="-">링크 다루기</h4>
<h5 id="-">- 클릭 가능한 링크 다루기</h5>
<p>HTML 앵커태그(a)는 내비게이션 링크를 만들기에 가장 좋은 태그며 다음과 같이 세가지 방법으로 링크를 작성할 수 있다.</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/admin/users/list"</span>&gt;</span>List users<span class="tag">&lt;/<span class="title">a</span>&gt;</span></code></pre>
<p>다른 방법은 기본동작을 제거한 <code>a</code> 태그와 <code>ng-click</code> 디렉티브를 사용해 클릭 가능한 요소를 만들 수 있다.</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">ng-click</span>=<span class="value">"listUsers()"</span>&gt;</span>List users<span class="tag">&lt;/<span class="title">a</span>&gt;</span></code></pre>
<pre><code class="lang-javascript">$scope.listUsers = <span class="keyword">function</span>(){
    $location.path(<span class="string">"/admin/users/list"</span>);
};</code></pre>
<p>다른 하나는 AngularJS의 <code>ng-href</code>를 사용하면 동적인 URL을 쉽게 만들 수 있다.</p>
<pre><code><span class="tag">&lt;<span class="title">a</span> <span class="attribute">ng-href</span>=<span class="value">"/admin/users/<span class="variable">{{user.$id()}}</span>"</span>&gt;</span>Edit users<span class="tag">&lt;/<span class="title">a</span>&gt;</span></code></pre>
<h4 id="-">경로 정의 구조화</h4>
<h5 id="-">- 경로 정의를 여러 개의 모듈로 분할</h5>
<p>애플리케이션에서 특정 경로는 해당하는 모듈 안에서 정의한다. </p>
<p>AngularJS 모듈 시스템에는 모듈마다 <code>config</code> 함수가 있으므로 <code>$routeProvider</code> 서비스를 주입해서 경로를 정의할 수 있다.</p>
<p>예를 들어 사용자를 관리하는 모듈과 프로젝트를 관리하는 모듈이 있다면 각 모듈에서 다음과 같이 경로를 정의한다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'admin-users'</span>, [])
  .config(<span class="keyword">function</span>($routeProvider) {
    $routeProvider
      .when(<span class="string">'/admin/users'</span>, {templateUrl: <span class="string">'tpls/users/list.html'</span>})
      .when(<span class="string">'/admin/users/new'</span>,  {templateUrl: <span class="string">'tpls/users/new.html'</span>})
      .when(<span class="string">'/admin/users/:userid'</span>, {templateUrl: <span class="string">'tpls/users/edit.html'</span>})
      .otherwise({redirectTo: <span class="string">'/admin/users/list'</span>});
  })</code></pre>
<pre><code class="lang-javascript">angular.module(<span class="string">'admin-projects'</span>, [])
  .config(<span class="keyword">function</span>($routeProvider) {
    $routeProvider
      .when(<span class="string">'/admin/projects'</span>, {templateUrl: <span class="string">'tpls/projects/list.html'</span>})
      .when(<span class="string">'/admin/projects/new'</span>,  {templateUrl: <span class="string">'tpls/projects/new.html'</span>})
      .when(<span class="string">'/admin/projects/:userid'</span>, {templateUrl: <span class="string">'tpls/projects/edit.html'</span>})
      .otherwise({redirectTo: <span class="string">'/admin/projects/list'</span>});
  })</code></pre>
<pre><code class="lang-javascript">angular.module(<span class="string">'admin'</span>, [<span class="string">'admin-projects'</span>, <span class="string">'admin-users'</span>]);</code></pre>
<h2 id="-">애플리케이션 보안</h2>
<h2 id="-">디렉티브 작성</h2>
<p>다음과 같은 경우에 사용자 정의 디렉티브가 필요하다.</p>
<ul>
<li>제이쿼리로 DOM을 직접 조작해야 하는 경우</li>
<li>중복된 코드를 제거해 애플리케이션의 특정 부분을 리팩토링하고 싶은 경우</li>
<li>개발자가 아닌 디자이너도 사용할 수 있는 새로운 HTML 마크업을 만들고 싶은 경우</li>
</ul>
<h3 id="angularjs-">AngularJS 디렉티브란</h3>
<p>디렉티브는 애플리케이션 로직과 HTML DOM 사이를 이어주는 접착제 역할을 한다. 디렉티브 안에서는 제이쿼리나 AngularJS의 jqLite를 통해 좀 더 어려운 저수준의 DOM 조작이 일어난다.</p>
<p><em>디렉티브의 주 업무는 DOM 구조를 변경하고 스코프와 DOM을 연결해주는 것이다.</em> 즉, 스코프의 데이터에 DOM 노드를 연결하고 조작하는 것은 물론 스코프의 메소드를 호출하기 위해 DOM 이벤트를 연결하는 역할도 맡는다.</p>
<h3 id="-">디렉티브 컴파일 생명주기</h3>
<p>AngularJS가 HTML 템플릿을 컴파일할 때는 브라우저가 제공하는 DOM을 돌아다니면서 각 요소, 속성, 주석, CSS 클래스에 대해 등록된 디렉티브 목록과 일치하는게 있는지 하나씩 확인한다. 그러다 <em>일치하는 디렉티브를 발견하면 AngularJS는 디렉티브의 컴파일 함수를 호출하고, 이 함수는 링크 함수를 반환한다.</em> 그리고 AngularJS는 이런 링크 함수를 모두 모아놓는다.</p>
<blockquote>
<p>스코프가 준비되기 전에 컴파일 단계는 모두 완료된다. 따라서 <em>컴파일 함수에서는 스코프 데이터를 사용할 수 없다.</em></p>
</blockquote>
<p>모든 <em>디렉티브가 컴파일되면 AngularJS는 스코프를 생성하고 각 디렉티브의 링크함수를 호춣해서 디렉티브와 스코프를 연결한다.</em></p>
<blockquote>
<p>링크 단계에서 스코프와 디렉티브가 연결되고 나면 링크 함수는 스코프와 DOM에 대한 바인딩을 설정한다.</p>
</blockquote>
<p>반복적으로 사용할 디렉티브를 고려하고 있다면 <em>디렉티브의 컴파일 함수는 오직 한 번만 호출되지만 링크 함수는 반복되는 각 디렉티브마다, 즉 데이터가 변경될 때마다 호출된다는 점을 알아두자.</em></p>
<p>스코프의 데이터와 상관없이 복잡한 기능을 구현해야 한다면 컴파일 함수에 구현하는 것이 좋다. 오직 한번만 호출되기 때문이다.</p>
<h3 id="-">디렉티브 정의</h3>
<p>각 디렉티브는 반드시 모듈로 정의해야 한다. 그리고 모듈에서 <code>directive()</code> 함수를 호출하면 된다. 매개변수로는 디렉티브의 이름과 디렉티브를 정의한 객체를 반환하는 팩토리 함수를 넘긴다.</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'app'</span>, [])
    .directive(<span class="string">'myDir'</span>, <span class="keyword">function</span>(){
        <span class="keyword">return</span> myDirectiveDefinition;
    });</code></pre>
<p>디렉티브에서 서비스를 사용하고 싶다면 팩토리 함수로 주입해서 사용하면 된다.</p>
<p>다음 표는 디렉티브를 정의할 때 사용할 수 있는 모든 필드에 대한 설명이다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>디렉티브 이름</td>
</tr>
<tr>
<td>restrict</td>
<td>디렉티브를 표시할 마크업의 종류</td>
</tr>
<tr>
<td>priority</td>
<td>컴파일러를 위해 정의하는 디렉티브의 실행 우선순위</td>
</tr>
<tr>
<td>terminal</td>
<td>컴파일러가 바로 다음 디렉티브도 컴파일해야 하는지의 여부</td>
</tr>
<tr>
<td>link</td>
<td>디렉티브를 스코프에 연결해주는 링크 함수</td>
</tr>
<tr>
<td>template</td>
<td>디렉티브가 생성하는 문자열로 표현된 마크업</td>
</tr>
<tr>
<td>templateUrl</td>
<td>디렉티브를 위한 템플릿의 URL</td>
</tr>
<tr>
<td>replace</td>
<td>디렉티브의 요소가 템플릿으로 정의한 내용으로 변경돼야 하는지의 여부</td>
</tr>
<tr>
<td>transclude</td>
<td>디렉티브의 요소 내용을 템플릿과 컴파일 함수에 제공할지의 여부</td>
</tr>
<tr>
<td>scope</td>
<td>디렉티브에 새로운 자식 스코프나 isolate 스코프를 만들지의 여부</td>
</tr>
<tr>
<td>controller</td>
<td>디렉티브의 컨트롤러 역할을 해줄 함수</td>
</tr>
<tr>
<td>require</td>
<td>디렉티브의 링크 함수에 주입되는 또 다른 컨트롤러를 정의한 디렉티브</td>
</tr>
<tr>
<td>compile</td>
<td>DOM을 조작하고 링크 함수를 만들어내며 링크를 따로 정의하지 않으면 이 함수만 사용되는 컴파일 함수</td>
</tr>
</tbody>
</table>
<h3 id="-">디렉티브로 버튼 꾸미기</h3>
<p>부트스트랩 CSS로 버튼 디렉티브를 만들어 보자.</p>
<p>먼저 부트스트랩을 이용한 마크업과 CSS 클래스는 다음과 같다.</p>
<pre><code><span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">class</span>=<span class="value">"btn btn-primary btn-large"</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="title">button</span>&gt;</span></code></pre>
<p>먼저 모든 버튼에 <code>class=&quot;btn&quot;</code>을 추가해야 하고 <code>type=&quot;submit&quot;</code>인 모든 버튼에는 <code>class=&quot;btn-primary&quot;</code>도 추가해야 한다.
그리고 size 속성으로 버튼의 크기도 정할 수 있다고 하자.</p>
<p>디렉티브가 적용된 마크업은 다음과 같다.</p>
<pre><code><span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">size</span>=<span class="value">"large"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span></code></pre>
<p>디렉티브는 다음과 같이 구현할 수 있다.</p>
<pre><code class="lang-javascript">myModule.directive(<span class="string">'button'</span>, <span class="keyword">function</span>(){
    <span class="keyword">return</span> {
        restrict : <span class="string">'E'</span>,
        compile : <span class="keyword">function</span>(element, attributes){
            element.addClass(<span class="string">'btn'</span>);
            <span class="keyword">if</span>(attributes.type == <span class="string">'submit'</span>){
                element.addClass(<span class="string">'btn-primary'</span>);
            }
            <span class="keyword">if</span>(attributes.size){
                element.addClass(<span class="string">'btn-'</span>+attributes.size);
            }
        }
    };
});</code></pre>
<p>AngularJS 컴파일러가 버튼 요소를 발견할 때마다 이 디렉티브가 적용된다. 사실상 <em>표준 HTML 요소에 새로운 동작을 추가</em>한 것이다.</p>
<p>컴파일 함수에는 <code>element</code>라는 매개변수를 넘기는데, 이 매개변수는 제이쿼리 혹인 jqList 객체로 디렉티브를 정의한 DOM 요소, 즉 여기서는 버튼 요소를 가리킨다.</p>
<p>컴파일 함수에서는 요소의 속성 값을 기준으로 클래스를 요소에 추가한다. 이때 요소의 속성에 접근하기 위해 주입된 <code>attributes</code> 매개변수를 사용한다.</p>
<p>이런 작업을 링크 함수가 아닌 컴파일 함수에서 하는 이유는 요소마다 바인딩되는 스코프 데이터와는 아무런 상관이 없기 때문이다. 물론 링크함수에도 넣을 수 있껬지만, 버튼을 <code>ng-repeat</code>의 루프 안에서 사용한다면 <code>addClass()</code>가 매번 호출될 것이다.</p>
<p><em>컴파일 함수에 기능을 추가하면 오직 한 번만 호출되기 때문에 <code>ng-repeat</code> 디렉티브는 단순히 버튼을 복제한다. DOM에 대한 복잡한 기능을 추가해야 한다면 이런 선택이 굉장한 성능 차이를 만들 수 있다. 특히 매우 많은 컬렉션을 반복해야 할 때는 더욱 큰 차이를 만든다.</em></p>
<h2 id="-">고급 디렉티브 작성</h2>
<h2 id="-">웹애플리케이션 작성</h2>

		  <!-- //end -->
		  </div>

      </section>

	  <!-- footer //-->
		        <footer>
		          <p>This project is maintained by <a href="https://github.com/mylko72">mylko72</a></p>
		          <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
		        </footer>

	  <!--// footer -->

    </div>
	<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
	<script src="https://code.jquery.com/ui/1.10.4/jquery-ui.min.js"></script>
	<script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
	<script src="http://gregfranko.com/jquery.tocify.js/js/jquery.tocify.js"></script>
    <script src="http://mylko72.github.io/FEDNote/javascripts/scale.fix.js"></script>
	<script src="http://mylko72.github.io/FEDNote/javascripts/highlight.pack.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r224/prettify.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
	<script src="/javascripts/marked.js"></script>
	<script src="/javascripts/markdown-toc.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
    
  </body>
</html>
